<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OLE Prompt Library</title>
  <style>
    :root {
      --bg: #0f1220;
      --card: #171a2b;
      --muted: #9aa3b2;
      --text: #e8ecf1;
      --accent: #5ad1ff;
      --border: #262b45;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, Noto Sans, Liberation Sans, Helvetica Neue, sans-serif; background: var(--bg); color: var(--text); }
    header { padding: 20px 16px; border-bottom: 1px solid var(--border); position: sticky; top: 0; background: linear-gradient(180deg, rgba(15,18,32,0.96), rgba(15,18,32,0.85)); backdrop-filter: blur(6px); z-index: 2; }
    .wrap { max-width: 1100px; margin: 0 auto; display: grid; grid-template-columns: 300px 1fr; gap: 16px; padding: 18px 16px 40px; }
    @media (max-width: 900px) { .wrap { grid-template-columns: 1fr; } }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 14px; }

    #sidebar { padding: 10px; display: flex; flex-direction: column; gap: 10px; height: fit-content; position: sticky; top: 76px; }
    #search { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid var(--border); background: #12162a; color: var(--text); outline: none; }
    #list { max-height: 70vh; overflow: auto; padding-right: 4px; }
    #list ul { list-style: none; margin: 0; padding-left: 16px; }
    #list > ul { padding-left: 0; }
    .tree-dir { display: flex; align-items: center; gap: 6px; padding: 6px 10px; border-radius: 10px; cursor: pointer; color: var(--text); }
    .tree-dir:hover { background: #141936; }
    .tree-dir button { appearance: none; border: none; background: none; color: var(--muted); cursor: pointer; font-size: 12px; display: flex; align-items: center; justify-content: center; width: 18px; }
    .tree-dir button:focus { outline: 1px solid var(--accent); border-radius: 4px; }
    .tree-dir .folder-name { font-size: 13px; font-weight: 600; }
    .tree-dir .github-folder-icon { margin-left: 4px; cursor: pointer; opacity: 0.6; transition: opacity 0.2s; font-size: 12px; }
    .tree-dir .github-folder-icon:hover { opacity: 1; }
    .tree-dir .add-file-icon { margin-left: 4px; cursor: pointer; opacity: 0.6; transition: opacity 0.2s; font-size: 12px; color: #4ade80; }
    .tree-dir .add-file-icon:hover { opacity: 1; }
    .item { display: flex; align-items: center; justify-content: space-between; gap: 8px; padding: 6px 10px; border-radius: 10px; border: 1px solid transparent; background: #12162a; cursor: pointer; }
    .item:hover { border-color: var(--border); background: #141936; }
    .item-title { font-size: 14px; font-weight: 600; }
    .item-meta { color: var(--muted); font-size: 12px; }
    .item.active { border-color: var(--accent); background: #151f3c; }

    #main { padding: 14px; }
    #empty { color: var(--muted); font-size: 14px; }
    #title { margin: 0 0 6px; font-size: 22px; }
    #meta { color: var(--muted); font-size: 13px; margin-bottom: 10px; }
    #actions { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 14px; }
    .btn { appearance: none; border: 1px solid var(--border); background: #11152a; color: var(--text); border-radius: 10px; padding: 8px 10px; font-size: 13px; cursor: pointer; }
    .btn:hover { border-color: #30365a; background: #151a33; }
    .btn:active { transform: translateY(1px); }
    #content { line-height: 1.55; font-size: 15px; }
    #content pre { background: #0b0f21; padding: 12px; border: 1px solid var(--border); border-radius: 10px; overflow: auto; }
    #content code { background: #0b0f21; padding: 1px 4px; border-radius: 6px; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    footer { max-width: 1100px; margin: 20px auto 40px; color: var(--muted); font-size: 13px; padding: 0 16px; }
    .pill { display: inline-flex; align-items: center; gap: 6px; padding: 6px 8px; border-radius: 999px; border: 1px solid var(--border); background: #11152a; font-size: 12px; color: var(--muted); }
    
    /* Branch dropdown styling */
    #branchSelect optgroup {
      font-weight: 600;
      color: var(--muted);
      font-size: 12px;
    }
    #branchSelect option {
      color: var(--text);
      font-weight: normal;
    }
    #branchSelect option[value="__toggle_features__"],
    #branchSelect option[value="__toggle_users__"] {
      font-weight: 600;
      color: var(--accent);
      background: var(--card);
      cursor: pointer;
    }
    #branchSelect option[value="__toggle_features__"]:hover,
    #branchSelect option[value="__toggle_users__"]:hover {
      background: rgba(90, 209, 255, 0.1);
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
  <header>
    <div class="wrap" style="padding:0;grid-template-columns:1fr;gap:0">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
        <div>
          <a href="https://ole-vi.github.io/prompt-sharing/" style="text-decoration:none; color:inherit;">
            <div style="font-size:18px; font-weight:800; letter-spacing:0.2px;">OLE Prompt Library</div>
          </a>
          <div style="color:var(--muted); font-size:13px;">Single file, no build. Drop .md files in <code>/prompts</code> and they show up here.</div>
        </div>
        <div style="display:flex; align-items:center; gap:8px;">
          <div class="pill" id="repoPill">Loading repo...</div>
          <!-- Chevron + branch select -->
          <label style="display:flex; align-items:center; gap:4px;">
            <span title="Choose a branch">‚ñº</span>
            <select id="branchSelect" class="btn" style="min-width:140px;">
              <option>Loading branches‚Ä¶</option>
            </select>
          </label>
        </div>
      </div>
    </div>
  </header>

  <div class="wrap">
    <aside id="sidebar" class="card">
      <input id="search" placeholder="Search prompts..." />
      <div id="list"></div>
      <div style="padding:8px 6px; color:var(--muted); font-size:12px;">
        Add prompts by committing <code>.md</code> files to <code>/prompts</code> in your repo. Use a first-level heading for the title.
      </div>
    </aside>

    <main id="main" class="card">
      <div id="empty">Select a prompt from the list. You can deep link to any prompt using the URL hash.</div>
      <h1 id="title" style="display:none"></h1>
      <div id="meta" style="display:none"></div>
      <div id="actions" style="display:none">
        <button class="btn" id="copyBtn" title="Copy the entire prompt">üìã Copy prompt</button>
        <button class="btn" id="shareBtn" title="Copy a link to this prompt">üîó Copy link</button>
        <a class="btn" id="editBtn" target="_blank" rel="noopener" title="Edit the file on GitHub">‚úèÔ∏è Edit on GitHub</a>
        <a class="btn" id="ghBtn" target="_blank" rel="noopener" title="Open the file on GitHub">üóÇÔ∏è View on GitHub</a>
        <a class="btn" id="rawBtn" target="_blank" rel="noopener" title="Open raw markdown">üìÑ Open raw</a>
      </div>
      <article id="content"></article>
    </main>
  </div>

  <footer>
    <div>Switch branches/owners/repos via URL or the dropdown. Examples: <code>?branch=Jesse</code> or <code>?owner=ole-vi&repo=prompt-sharing&branch=main</code>.</div>
  </footer>

  <script>
    const OWNER  = "ole-vi";
    const REPO   = "prompt-sharing";
    const BRANCH = "main";
    const PRETTY_TITLES = true;

    function parseParams() {
      const out = {};
      const sources = [
        location.search || "",
        location.hash && location.hash.includes("?")
          ? location.hash.slice(location.hash.indexOf("?"))
          : ""
      ];
      for (const src of sources) {
        const p = new URLSearchParams(src);
        for (const [k, v] of p.entries()) out[k.toLowerCase()] = v;
      }
      return out;
    }

    const params = parseParams();
    let currentOwner  = params.owner  || OWNER;
    let currentRepo   = params.repo   || REPO;
    let currentBranch = params.branch || BRANCH;

    let files = [];
    let cacheRaw = new Map();
    let currentSlug = null;
    let expandedState = new Set();
    let expandedStateKey = null;

    const listEl   = document.getElementById('list');
    const contentEl= document.getElementById('content');
    const titleEl  = document.getElementById('title');
    const metaEl   = document.getElementById('meta');
    const emptyEl  = document.getElementById('empty');
    const actionsEl= document.getElementById('actions');
    const copyBtn  = document.getElementById('copyBtn');
    const rawBtn   = document.getElementById('rawBtn');
    const ghBtn    = document.getElementById('ghBtn');
    const editBtn  = document.getElementById('editBtn');
    const shareBtn = document.getElementById('shareBtn');
    const searchEl = document.getElementById('search');
    const repoPill = document.getElementById('repoPill');
    const branchSelect = document.getElementById('branchSelect');

    const rawURL = (path) =>
      `https://raw.githubusercontent.com/${currentOwner}/${currentRepo}/${currentBranch}/${path}`;

    const GIST_POINTER_REGEX = /^https:\/\/gist\.githubusercontent\.com\/\S+\/raw\/\S+$/i;
    const GIST_URL_REGEX = /^https:\/\/gist\.github\.com\/[\w-]+\/[a-f0-9]+\/?(?:#file-[\w.-]+)?(?:\?file=[\w.-]+)?$/i;
    const CODEX_URL_REGEX = /^https:\/\/chatgpt\.com\/s\/[a-f0-9_]+$/i;

    async function resolveGistRawUrl(gistUrl) {
      // If it's already a raw URL, use it directly
      if (GIST_POINTER_REGEX.test(gistUrl)) {
        return gistUrl;
      }

      // Parse regular gist URLs
      const match = gistUrl.match(/^https:\/\/gist\.github\.com\/([\w-]+)\/([a-f0-9]+)\/?(?:#file-([\w.-]+))?(?:\?file=([\w.-]+))?$/i);
      if (!match) {
        throw new Error('Invalid gist URL format');
      }

      const [, user, gistId, fragmentFile, queryFile] = match;
      const targetFile = fragmentFile || queryFile;

      if (targetFile) {
        // Specific file requested
        return `https://gist.githubusercontent.com/${user}/${gistId}/raw/${targetFile}`;
      } else {
        // No specific file - fetch gist metadata to find the best file
        const apiUrl = `https://api.github.com/gists/${gistId}`;
        const res = await fetch(apiUrl);
        if (!res.ok) {
          throw new Error(`Failed to fetch gist metadata: ${res.status}`);
        }
        const gistData = await res.json();
        const files = Object.keys(gistData.files);
        
        let bestFile = files.find(f => f.endsWith('.md')) || files[0];
        
        if (!bestFile) {
          throw new Error('No files found in gist');
        }
        
        return `https://gist.githubusercontent.com/${user}/${gistId}/raw/${bestFile}`;
      }
    }

    async function fetchGistContent(gistUrl) {
      const cacheKey = `gist:${gistUrl}`;
      if (cacheRaw.has(cacheKey)) {
        return cacheRaw.get(cacheKey);
      }
      const url = gistUrl.includes('?')
        ? `${gistUrl}&ts=${Date.now()}`
        : `${gistUrl}?ts=${Date.now()}`;
      const res = await fetch(url, { cache: 'no-store' });
      if (!res.ok) {
        throw new Error(`Gist fetch failed: ${res.status} ${res.statusText}`);
      }
      const text = await res.text();
      cacheRaw.set(cacheKey, text);
      return text;
    }

    function slugify(filePath) {
      const base = filePath.replace(/\.md$/i, '').toLowerCase().replace(/\s+/g, '-');
      return encodeURIComponent(base);
    }

    function getExpandedStateKey() {
      return `sidebar:expanded:${currentOwner}/${currentRepo}@${currentBranch}`;
    }

    function loadExpandedState() {
      const key = getExpandedStateKey();
      if (expandedStateKey === key) return;
      expandedStateKey = key;
      try {
        const raw = sessionStorage.getItem(key);
        const parsed = raw ? JSON.parse(raw) : [];
        expandedState = new Set(Array.isArray(parsed) ? parsed : []);
      } catch {
        expandedState = new Set();
      }
      expandedState.add('prompts');
    }

    function persistExpandedState() {
      const key = getExpandedStateKey();
      expandedStateKey = key;
      try {
        sessionStorage.setItem(key, JSON.stringify([...expandedState]));
      } catch {}
    }

    function prettyTitle(name) {
      const base = name.replace(/\.md$/i, "");
      const addEmoji = (s) => {
        if (!PRETTY_TITLES) return s;
        if (/review|pr|rubric/i.test(s)) return "üîç " + s;
        if (/bug|triage|fix/i.test(s)) return "ü©π " + s;
        if (/spec|design|plan/i.test(s)) return "üß≠ " + s;
        if (/refactor/i.test(s)) return "üßπ " + s;
        return s;
      };
      return addEmoji(base.replace(/[-_]/g, " "));
    }

    async function fetchJSON(url) {
      const res = await fetch(url, {
        cache: 'no-store',
        headers: { 'Accept': 'application/vnd.github+json' }
      });
      if (!res.ok) {
        const txt = await res.text().catch(() => '');
        const err = new Error(`GitHub API ${res.status} ${res.statusText} ${txt.slice(0,140)}`);
        err.status = res.status;
        throw err;
      }
      return res.json();
    }

    async function listPromptsViaContents(path = 'prompts') {
      const url = `https://api.github.com/repos/${currentOwner}/${currentRepo}/contents/${path}?ref=${encodeURIComponent(currentBranch)}&ts=${Date.now()}`;
      const entries = await fetchJSON(url);
      if (!Array.isArray(entries)) return [];

      const results = [];
      for (const entry of entries) {
        if (entry.type === 'file' && /\.md$/i.test(entry.name)) {
          results.push({
            type: 'file',
            name: entry.name,
            path: entry.path,
            sha: entry.sha,
            download_url: entry.download_url
          });
        } else if (entry.type === 'dir') {
          const children = await listPromptsViaContents(entry.path);
          results.push(...children);
        }
      }
      return results;
    }

    async function listPromptsViaTrees() {
      const url = `https://api.github.com/repos/${currentOwner}/${currentRepo}/git/trees/${encodeURIComponent(currentBranch)}?recursive=1&ts=${Date.now()}`;
      const data = await fetchJSON(url);
      const items = (data.tree || []).filter(n => n.type === 'blob' && /^prompts\/.+\.md$/i.test(n.path));
      return items.map(n => ({
        type: 'file',
        name: n.path.split('/').pop(),
        path: n.path,
        sha: n.sha
      }));
    }

    async function refreshList(cacheKey) {
      let data;
      try {
        data = await listPromptsViaContents();
      } catch (e) {
        if (e.status === 403 || e.status === 404) {
          data = await listPromptsViaTrees();
        } else {
          throw e;
        }
      }
      files = (data || []).filter(x => x && x.type === 'file' && typeof x.path === 'string');
      sessionStorage.setItem(cacheKey, JSON.stringify(files));
      renderList(files);
    }

    async function loadList() {
      repoPill.textContent = `${currentOwner}/${currentRepo}@${currentBranch}`;
      const cacheKey = `prompts:${currentOwner}/${currentRepo}@${currentBranch}`;

      try {
        const cached = sessionStorage.getItem(cacheKey);
        if (cached) {
          files = JSON.parse(cached);
          renderList(files);
          refreshList(cacheKey).catch(() => {});
          const match = location.hash.match(/[#&?]p=([^&]+)/) || location.hash.match(/^#([^&]+)$/);
          if (match) selectBySlug(decodeURIComponent(match[1]));
          return;
        }

        await refreshList(cacheKey);
        const match = location.hash.match(/[#&?]p=([^&]+)/) || location.hash.match(/^#([^&]+)$/);
        if (match) selectBySlug(decodeURIComponent(match[1]));
      } catch (e) {
        listEl.innerHTML = `<div style="color:var(--muted); padding:8px;">
          Could not load prompts from <code>${currentOwner}/${currentRepo}@${currentBranch}/prompts</code>.<br/>${e.message}
        </div>`;
      }
    }

    function ancestorPaths(path) {
      const parts = path.split('/');
      const ancestors = [];
      for (let i = 0; i < parts.length - 1; i++) {
        ancestors.push(parts.slice(0, i + 1).join('/'));
      }
      return ancestors;
    }

    function ensureAncestorsExpanded(path) {
      const ancestors = ancestorPaths(path);
      let changed = false;
      for (const dir of ancestors) {
        if (!expandedState.has(dir)) {
          expandedState.add(dir);
          changed = true;
        }
      }
      if (changed) persistExpandedState();
      return changed;
    }

    function buildTree(items) {
      const root = { type: 'dir', name: 'prompts', path: 'prompts', children: new Map() };
      for (const item of items) {
        if (!item.path) continue;
        const relative = item.path.replace(/^prompts\/?/, '');
        const segments = relative.split('/');
        let node = root;
        let currentPath = 'prompts';
        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i];
          const isFile = i === segments.length - 1;
          if (isFile) {
            node.children.set(segment, { ...item, type: 'file' });
          } else {
            currentPath = `${currentPath}/${segment}`;
            if (!node.children.has(segment)) {
              node.children.set(segment, {
                type: 'dir',
                name: segment,
                path: currentPath,
                children: new Map()
              });
            }
            node = node.children.get(segment);
          }
        }
      }
      return root;
    }

    function toggleDirectory(path, expand) {
      const before = expandedState.has(path);
      if (expand) {
        expandedState.add(path);
      } else {
        expandedState.delete(path);
      }
      if (before !== expand) {
        persistExpandedState();
      }
      renderList(files);
    }

    function renderTree(node, container, forcedExpanded) {
      const entries = Array.from(node.children.values());
      entries.sort((a, b) => {
        if (a.type !== b.type) return a.type === 'dir' ? -1 : 1;
        const aName = (a.name || '').toLowerCase();
        const bName = (b.name || '').toLowerCase();
        return aName.localeCompare(bName);
      });

      for (const entry of entries) {
        if (entry.type === 'dir') {
          const li = document.createElement('li');
          const header = document.createElement('div');
          header.className = 'tree-dir';
          const toggle = document.createElement('button');
          toggle.type = 'button';
          const isForced = forcedExpanded.has(entry.path);
          const isExpanded = isForced || expandedState.has(entry.path);
          toggle.textContent = isExpanded ? '‚ñæ' : '‚ñ∏';
          toggle.addEventListener('click', (ev) => {
            ev.stopPropagation();
            toggleDirectory(entry.path, !isExpanded);
          });
          header.addEventListener('click', (ev) => {
            ev.stopPropagation();
            toggleDirectory(entry.path, !isExpanded);
          });
          const label = document.createElement('span');
          label.className = 'folder-name';
          label.textContent = entry.name;
          
          const ghIcon = document.createElement('span');
          ghIcon.className = 'github-folder-icon';
          ghIcon.textContent = 'üóÇÔ∏è';
          ghIcon.title = 'Open directory on GitHub';
          ghIcon.addEventListener('click', (ev) => {
            ev.stopPropagation();
            const ghUrl = `https://github.com/${currentOwner}/${currentRepo}/tree/${currentBranch}/${entry.path}`;
            window.open(ghUrl, '_blank', 'noopener,noreferrer');
          });
          
          const addIcon = document.createElement('span');
          addIcon.className = 'add-file-icon';
          addIcon.textContent = '+';
          addIcon.title = 'Create new file in this directory';
          addIcon.addEventListener('click', (ev) => {
            ev.stopPropagation();
            const newFilePath = entry.path ? `${entry.path}/new-prompt.md` : 'new-prompt.md';
            const ghUrl = `https://github.com/${currentOwner}/${currentRepo}/new/${currentBranch}?filename=${newFilePath}`;
            window.open(ghUrl, '_blank', 'noopener,noreferrer');
          });
          
          header.appendChild(toggle);
          header.appendChild(label);
          header.appendChild(ghIcon);
          header.appendChild(addIcon);
          li.appendChild(header);

          const childList = document.createElement('ul');
          childList.style.display = isExpanded ? 'block' : 'none';
          li.appendChild(childList);
          renderTree(entry, childList, forcedExpanded);
          if (!childList.children.length) {
            continue;
          }
          container.appendChild(li);
        } else {
          const file = entry;
          const li = document.createElement('li');
          const slug = slugify(file.path);
          const a = document.createElement('a');
          a.className = 'item';
          a.href = `#p=${encodeURIComponent(slug)}`;
          a.dataset.slug = slug;
          a.addEventListener('click', (ev) => {
            ev.preventDefault();
            selectFile(file, true);
          });

          const left = document.createElement('div');
          left.style.display = 'flex';
          left.style.flexDirection = 'column';
          left.style.gap = '2px';
          const t = document.createElement('div');
          t.className = 'item-title';
          t.textContent = prettyTitle(file.name);
          left.appendChild(t);
          a.appendChild(left);
          li.appendChild(a);
          container.appendChild(li);
        }
      }
    }

    function renderList(items) {
      loadExpandedState();
      const q = searchEl.value?.trim().toLowerCase();
      const searchActive = Boolean(q);
      const filtered = !q
        ? items.slice()
        : items.filter(f => {
            const name = f.name?.toLowerCase?.() || '';
            const path = f.path?.toLowerCase?.() || '';
            return name.includes(q) || path.includes(q);
          });

      if (!filtered.length) {
        listEl.innerHTML = '<div style="color:var(--muted); padding:8px;">No prompts found.</div>';
        return;
      }

      const forcedExpanded = new Set();
      if (searchActive) {
        for (const file of filtered) {
          for (const ancestor of ancestorPaths(file.path)) {
            forcedExpanded.add(ancestor);
          }
        }
      }

      listEl.innerHTML = '';
      const rootList = document.createElement('ul');
      listEl.appendChild(rootList);
      const tree = buildTree(filtered);
      renderTree(tree, rootList, forcedExpanded);
      updateActiveItem();
    }

    function updateActiveItem() {
      const anchors = listEl.querySelectorAll('.item');
      anchors.forEach((a) => {
        if (a.dataset.slug === currentSlug) {
          a.classList.add('active');
        } else {
          a.classList.remove('active');
        }
      });
    }

    async function selectBySlug(slug) {
      const f = files.find(x => slugify(x.path) === slug);
      if (f) selectFile(f, false);
    }

    async function selectFile(f, pushHash) {
      if (!f) {
        editBtn.style.display = 'none';
        editBtn.removeAttribute('href');
        return;
      }

      emptyEl.style.display = 'none';
      titleEl.style.display = 'block';
      metaEl.style.display = 'block';
      actionsEl.style.display = 'flex';
      titleEl.textContent = prettyTitle(f.name);
      metaEl.textContent = `File: ${f.path}`;
      const slug = slugify(f.path);
      if (pushHash) history.pushState(null, '', `#p=${encodeURIComponent(slug)}`);
      currentSlug = slug;

      const expanded = ensureAncestorsExpanded(f.path);
      if (expanded) {
        renderList(files);
      } else {
        updateActiveItem();
      }

      let cached = cacheRaw.get(slug);
      let raw;
      let isGistContent = false;
      let isCodexContent = false;
      let gistUrl = null;
      let codexUrl = null;

      if (cached) {
        console.log('Using cached content:', typeof cached, cached);
        if (typeof cached === 'string') {
          raw = cached;
        } else {
          if (cached.gistUrl) {
            isGistContent = true;
            gistUrl = cached.gistUrl;
            console.log('Cache contains gist URL, refetching...');
            try {
              const finalRawUrl = cached.rawGistUrl || await resolveGistRawUrl(cached.gistUrl);
              console.log('Using raw URL:', finalRawUrl);
              const gistBody = await fetchGistContent(finalRawUrl);
              console.log('Refetched gist content length:', gistBody.length);
              raw = gistBody;
              cached.body = gistBody;
              cached.rawGistUrl = finalRawUrl;
            } catch (err) {
              console.error('Failed to refetch gist:', err);
              raw = cached.body || `Error loading gist: ${err.message}`;
            }
          } else if (cached.codexUrl) {
            isCodexContent = true;
            codexUrl = cached.codexUrl;
            console.log('Cache contains codex URL, using cached content...');
            raw = cached.body;
          } else {
            raw = cached.body || cached;
          }
        }
      } else {
        const res = await fetch(rawURL(f.path) + `?ts=${Date.now()}`, { cache: 'no-store' });
        let text = await res.text();
        const trimmed = text.trim();
        
        if (GIST_POINTER_REGEX.test(trimmed) || GIST_URL_REGEX.test(trimmed)) {
          isGistContent = true;
          gistUrl = trimmed;
          console.log('Detected gist URL:', trimmed);
          try {
            const rawGistUrl = await resolveGistRawUrl(trimmed);
            console.log('Resolved to raw URL:', rawGistUrl);
            const gistBody = await fetchGistContent(rawGistUrl);
            console.log('Fetched gist content length:', gistBody.length);
            raw = gistBody;
            cacheRaw.set(slug, { body: gistBody, gistUrl: trimmed, rawGistUrl });
          } catch (err) {
            console.error('Failed to fetch gist:', err);
            raw = text;
            cacheRaw.set(slug, { body: text, gistUrl: trimmed, error: err.message });
          }
        } else if (CODEX_URL_REGEX.test(trimmed)) {
          isCodexContent = true;
          codexUrl = trimmed;
          console.log('Detected codex URL:', trimmed);
          raw = trimmed;
          cacheRaw.set(slug, { body: raw, codexUrl: trimmed });
        } else {
          console.log('Not a gist or codex URL, using original text');
          raw = text;
          cacheRaw.set(slug, raw);
        }
      }

      if (isGistContent && gistUrl) {
        editBtn.textContent = '‚úèÔ∏è Edit Link';
        editBtn.title = 'Edit the gist link';
        ghBtn.textContent = 'üóÇÔ∏è View on Gist';
        ghBtn.title = 'Open the gist on GitHub';
        ghBtn.href = gistUrl;
        const blob = new Blob([raw], { type: 'text/plain' });
        const dataUrl = URL.createObjectURL(blob);
        rawBtn.href = dataUrl;
        rawBtn.removeAttribute('download');
        rawBtn.title = 'Open gist content in new tab';
      } else if (isCodexContent && codexUrl) {
        editBtn.textContent = '‚úèÔ∏è Edit Link';
        editBtn.title = 'Edit the codex link';
        ghBtn.textContent = 'üí¨ View on Codex';
        ghBtn.title = 'Open the conversation on Codex';
        ghBtn.href = codexUrl;
        ghBtn.target = '_blank';
        const blob = new Blob([codexUrl], { type: 'text/plain' });
        const dataUrl = URL.createObjectURL(blob);
        rawBtn.href = dataUrl;
        rawBtn.target = '_blank';
        rawBtn.removeAttribute('download');
        rawBtn.title = 'Open raw link in new tab';
      } else {
        editBtn.textContent = '‚úèÔ∏è Edit on GitHub';
        editBtn.title = 'Edit the file on GitHub';
        ghBtn.textContent = 'üóÇÔ∏è View on GitHub';
        ghBtn.title = 'Open the file on GitHub';
        ghBtn.href = `https://github.com/${currentOwner}/${currentRepo}/blob/${currentBranch}/${f.path}`;
        rawBtn.href = rawURL(f.path);
        rawBtn.title = 'Open raw markdown';
      }
      editBtn.style.display = '';
      editBtn.href = `https://github.com/${currentOwner}/${currentRepo}/edit/${currentBranch}/${f.path}`;
      
      if (isCodexContent) {
        copyBtn.style.display = 'none';
        shareBtn.textContent = 'üîó Copy link';
      } else {
        copyBtn.style.display = '';
        copyBtn.textContent = 'üìã Copy prompt';
        shareBtn.textContent = 'üîó Copy link';
      }
      
      copyBtn.onclick = async () => {
        try {
          let contentToCopy;
          let buttonText;
          
          if (isCodexContent && codexUrl) {
            contentToCopy = codexUrl;
            buttonText = 'üìã Copy link';
            console.log('Copying codex URL:', codexUrl);
          } else {
            contentToCopy = raw;
            buttonText = 'üìã Copy prompt';
            console.log('Copying content:', raw.substring(0, 100) + (raw.length > 100 ? '...' : ''));
          }
          
          await navigator.clipboard.writeText(contentToCopy);
          copyBtn.textContent = 'Copied';
          setTimeout(() => copyBtn.textContent = buttonText, 1000);
        } catch {
          alert('Clipboard blocked. Select and copy manually.');
        }
      };
      shareBtn.onclick = async () => {
        try {
          await navigator.clipboard.writeText(location.href);
          shareBtn.textContent = 'Link copied';
        } catch {
          alert('Could not copy link.');
        } finally {
          const originalText = 'üîó Copy link';
          setTimeout(() => (shareBtn.textContent = originalText), 1000);
        }
      };

      const firstLine = raw.split(/\r?\n/)[0];
      if (/^#\s+/.test(firstLine)) {
        titleEl.textContent = firstLine.replace(/^#\s+/, '');
      }

      if (isGistContent) {
        const looksLikeMarkdown = /^#|^\*|^-|^\d+\.|```/.test(raw.trim());
        if (!looksLikeMarkdown) {
          const wrappedContent = '```\n' + raw + '\n```';
          contentEl.innerHTML = marked.parse(wrappedContent, { breaks: true });
        } else {
          contentEl.innerHTML = marked.parse(raw, { breaks: true });
        }
      } else {
        contentEl.innerHTML = marked.parse(raw, { breaks: true });
      }
      
      enhanceCodeBlocks();
    }

    function enhanceCodeBlocks() {
      const pres = contentEl.querySelectorAll('pre');
      pres.forEach((pre) => {
        if (pre.querySelector('.copy')) return;
        const btn = document.createElement('button');
        btn.textContent = 'Copy';
        btn.className = 'btn copy';
        btn.style.position = 'absolute';
        btn.style.margin = '6px';
        btn.style.right = '8px';
        btn.style.transform = 'translateY(-2px)';
        const wrapper = document.createElement('div');
        wrapper.style.position = 'relative';
        pre.parentNode.insertBefore(wrapper, pre);
        wrapper.appendChild(pre);
        wrapper.appendChild(btn);
        btn.addEventListener('click', async () => {
          const code = pre.innerText;
          try {
            await navigator.clipboard.writeText(code);
            btn.textContent = 'Copied';
            setTimeout(() => (btn.textContent = 'Copy'), 900);
          } catch {}
        });
      });
    }

    function classifyBranch(branchName) {
      if (branchName === 'main' || branchName === 'master') {
        return 'main';
      }
      
      const userBranches = ['dogi', 'jesse', 'saksham'];
      if (userBranches.includes(branchName)) {
        return 'user';
      }
      
      if (
        branchName.startsWith('codex/') ||
        /^\d+-/.test(branchName) ||
        branchName.includes('feature/') ||
        branchName.includes('fix/') ||
        branchName.includes('bugfix/') ||
        branchName.includes('hotfix/') ||
        (branchName.includes('-') && branchName.length > 8)
      ) {
        return 'feature';
      }
      
      if (/^[a-zA-Z][a-zA-Z0-9]*$/.test(branchName) && branchName.length < 15) {
        return 'user';
      }
      
      return 'feature';
    }

    function toggleFeatureBranches() {
      const showFeatures = localStorage.getItem('showFeatureBranches') === 'true';
      const newShowFeatures = !showFeatures;
      localStorage.setItem('showFeatureBranches', newShowFeatures.toString());
      
      loadBranches();
    }

    function toggleUserBranches() {
      const showUsers = localStorage.getItem('showUserBranches') !== 'false';
      const newShowUsers = !showUsers;
      localStorage.setItem('showUserBranches', newShowUsers.toString());
      
      loadBranches();
    }

    async function loadBranches() {
      branchSelect.disabled = true;
      branchSelect.innerHTML = `<option>Loading branches‚Ä¶</option>`;
      try {
        const res = await fetch(
          `https://api.github.com/repos/${currentOwner}/${currentRepo}/branches?per_page=100&ts=${Date.now()}`,
          { cache: 'no-store', headers: { 'Accept': 'application/vnd.github+json' } }
        );
        if (!res.ok) {
          const txt = await res.text().catch(() => '');
          throw new Error(`GitHub API ${res.status} ${res.statusText} ${txt.slice(0,120)}`);
        }
        const branches = await res.json();

        const mainBranches = [];
        const userBranches = [];
        const featureBranches = [];
        
        for (const b of branches) {
          const category = classifyBranch(b.name);
          switch (category) {
            case 'main':
              mainBranches.push(b);
              break;
            case 'user':
              userBranches.push(b);
              break;
            case 'feature':
              featureBranches.push(b);
              break;
          }
        }

        userBranches.sort((a, b) => a.name.localeCompare(b.name));
        featureBranches.sort((a, b) => a.name.localeCompare(b.name));

        branchSelect.innerHTML = '';
        
        for (const b of mainBranches) {
          const opt = document.createElement('option');
          opt.value = b.name;
          opt.textContent = b.name;
          branchSelect.appendChild(opt);
        }
        
        if (userBranches.length > 0) {
          const showUsers = localStorage.getItem('showUserBranches') !== 'false'; // default: true
          const userGroup = document.createElement('optgroup');
          
          const userHeaderOpt = document.createElement('option');
          userHeaderOpt.value = '__toggle_users__';
          userHeaderOpt.textContent = `${showUsers ? '‚ñº' : '‚ñ∂'} User Branches (${userBranches.length})`;
          userHeaderOpt.style.fontWeight = '600';
          userHeaderOpt.style.color = 'var(--accent)';
          userHeaderOpt.style.backgroundColor = 'var(--card)';
          userGroup.appendChild(userHeaderOpt);
          
          if (showUsers) {
            for (const b of userBranches) {
              const opt = document.createElement('option');
              opt.value = b.name;
              opt.textContent = `  ${b.name}`;
              userGroup.appendChild(opt);
            }
          }
          branchSelect.appendChild(userGroup);
        }
        
        if (featureBranches.length > 0) {
          const showFeatures = localStorage.getItem('showFeatureBranches') === 'true';
          const featureGroup = document.createElement('optgroup');
          
          const headerOpt = document.createElement('option');
          headerOpt.value = '__toggle_features__';
          headerOpt.textContent = `${showFeatures ? '‚ñº' : '‚ñ∂'} Feature Branches (${featureBranches.length})`;
          headerOpt.style.fontWeight = '600';
          headerOpt.style.color = 'var(--accent)';
          headerOpt.style.backgroundColor = 'var(--card)';
          featureGroup.appendChild(headerOpt);
          
          if (showFeatures) {
            for (const b of featureBranches) {
              const opt = document.createElement('option');
              opt.value = b.name;
              opt.textContent = `  ${b.name}`;
              featureGroup.appendChild(opt);
            }
          }
          branchSelect.appendChild(featureGroup);
        }

        if (![...branchSelect.options].some(o => o.value === currentBranch)) {
          const opt = document.createElement('option');
          opt.value = currentBranch;
          opt.textContent = `${currentBranch} (unlisted)`;
          branchSelect.appendChild(opt);
        }
        
        branchSelect.value = currentBranch;
        branchSelect.title = '';
      } catch (e) {
        branchSelect.innerHTML = `<option value="${currentBranch}">${currentBranch}</option>`;
        branchSelect.title = (e && e.message) ? e.message : 'Failed to load branches';
      } finally {
        branchSelect.disabled = false;
      }
    }

    document.addEventListener('change', (e) => {
      if (e.target !== branchSelect) return;
      
      if (branchSelect.value === '__toggle_features__') {
        toggleFeatureBranches();
        return;
      }
      
      if (branchSelect.value === '__toggle_users__') {
        toggleUserBranches();
        return;
      }
      
      currentBranch = branchSelect.value;

      const qs = new URLSearchParams(location.search);
      qs.set('branch', currentBranch);
      const slugMatch = location.hash.match(/[#&?]p=([^&]+)/) || location.hash.match(/^#([^&]+)$/);
      const slug = slugMatch ? decodeURIComponent(slugMatch[1]) : null;

      const newUrl = `${location.pathname}?${qs.toString()}${slug ? '#p=' + encodeURIComponent(slug) : ''}`;
      history.replaceState(null, '', newUrl);

      cacheRaw.clear();
      loadList();
    });

    window.addEventListener('hashchange', () => {
      const p = parseParams();
      const prev = { owner: currentOwner, repo: currentRepo, branch: currentBranch };
      if (p.owner)  currentOwner  = p.owner;
      if (p.repo)   currentRepo   = p.repo;
      if (p.branch) currentBranch = p.branch;

      const repoChanged = currentOwner !== prev.owner || currentRepo !== prev.repo;
      const branchChanged = currentBranch !== prev.branch;

      if (repoChanged || branchChanged) {
        cacheRaw.clear();
        loadList();
        loadBranches();
      } else {
        const match = location.hash.match(/[#&?]p=([^&]+)/) || location.hash.match(/^#([^&]+)$/);
        if (match) selectBySlug(decodeURIComponent(match[1]));
      }
    });

    window.addEventListener('popstate', () => {
      const p = parseParams();
      const changed =
        (p.owner && p.owner !== currentOwner) ||
        (p.repo && p.repo !== currentRepo) ||
        (p.branch && p.branch !== currentBranch);
      if (changed) {
        currentOwner  = p.owner  || currentOwner;
        currentRepo   = p.repo   || currentRepo;
        currentBranch = p.branch || currentBranch;
        cacheRaw.clear();
        loadList();
        loadBranches();
      }
    });

    searchEl.addEventListener('input', () => {
      renderList(files);
    });

    loadList();
    loadBranches();
  </script>
</body>
</html>
